‚úÖ 3. ALL functions in public schema ONLY

[
  {
    "function_name": "auto_generate_coupon",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.auto_generate_coupon()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_reward_name TEXT;\r\n  v_discount_type TEXT;\r\n  v_discount_value TEXT;\r\n  v_code TEXT;\r\nBEGIN\r\n  -- Only process discount rewards\r\n  IF NEW.reward_type = 'discount' THEN\r\n    -- Get reward details\r\n    SELECT name INTO v_reward_name\r\n    FROM rewards_catalog\r\n    WHERE id = NEW.reward_id;\r\n\r\n    -- Parse discount type and value from reward_value\r\n    -- Format examples: \"10_percent_pro\", \"20_percent_premium\", \"free_month_pro\"\r\n    IF NEW.reward_value LIKE '%_percent_%' THEN\r\n      v_discount_type := 'percentage';\r\n      v_discount_value := split_part(NEW.reward_value, '_', 1); -- Extract number\r\n    ELSIF NEW.reward_value LIKE 'free_month_%' THEN\r\n      v_discount_type := 'free_month';\r\n      v_discount_value := split_part(NEW.reward_value, '_', 3); -- Extract plan type\r\n    ELSE\r\n      v_discount_type := 'percentage';\r\n      v_discount_value := '10'; -- Default\r\n    END IF;\r\n\r\n    -- Generate coupon\r\n    v_code := create_coupon_from_reward(\r\n      NEW.user_id,\r\n      NEW.reward_id,\r\n      v_reward_name,\r\n      v_discount_type,\r\n      v_discount_value,\r\n      30 -- Expires in 30 days\r\n    );\r\n\r\n    -- Create notification with user_id\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      icon,\r\n      action_url,\r\n      metadata\r\n    ) VALUES (\r\n      NEW.user_id,\r\n      'success',\r\n      'Coupon Ready!',\r\n      'Your coupon code ' || v_code || ' is ready! Check your coupons to use it.',\r\n      'üéüÔ∏è',\r\n      '/profile/coupons',\r\n      jsonb_build_object('coupon_code', v_code, 'reward_id', NEW.reward_id)\r\n    );\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "award_challenge_points",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.award_challenge_points()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_points INTEGER;\r\nBEGIN\r\n  -- Only award when challenge is marked complete\r\n  IF NEW.completed = TRUE AND (OLD.completed = FALSE OR OLD.completed IS NULL) THEN\r\n    -- Get challenge points\r\n    SELECT points INTO v_points\r\n    FROM challenges\r\n    WHERE id = NEW.challenge_id;\r\n    \r\n    -- Award points\r\n    INSERT INTO user_rewards (user_id, points, lifetime_points)\r\n    VALUES (NEW.user_id, v_points, v_points)\r\n    ON CONFLICT (user_id)\r\n    DO UPDATE SET\r\n      points = user_rewards.points + v_points,\r\n      lifetime_points = user_rewards.lifetime_points + v_points,\r\n      updated_at = NOW();\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "award_points",
    "arguments": "p_user_id uuid, p_points integer, p_reason text DEFAULT NULL::text",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION public.award_points(p_user_id uuid, p_points integer, p_reason text DEFAULT NULL::text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  UPDATE user_rewards\r\n  SET\r\n    points = points + p_points,\r\n    lifetime_points = lifetime_points + p_points,\r\n    updated_at = NOW()\r\n  WHERE user_id = p_user_id;\r\n\r\n  -- Create notification\r\n  INSERT INTO notifications (user_id, type, title, message)\r\n  VALUES (\r\n    p_user_id,\r\n    'achievement',\r\n    'Points Earned!',\r\n    format('You earned %s points%s', p_points, COALESCE(' for ' || p_reason, '!'))\r\n  );\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "calculate_meal_plan_adherence",
    "arguments": "p_user_id uuid, p_meal_plan_id uuid, p_date date",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION public.calculate_meal_plan_adherence(p_user_id uuid, p_meal_plan_id uuid, p_date date)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_planned_meals JSONB;\r\n  v_logged_meals JSONB;\r\n  v_meals_followed INTEGER := 0;\r\n  v_meals_total INTEGER;\r\nBEGIN\r\n  -- Get planned meals for this date from AI meal plan\r\n  -- This is simplified - you'd parse the plan_data to get meals for specific day\r\n  v_planned_meals := '[]'::jsonb;\r\n\r\n  -- Get logged meals for this date\r\n  SELECT jsonb_agg(\r\n    jsonb_build_object(\r\n      'meal_type', meal_type,\r\n      'calories', total_calories,\r\n      'from_ai_plan', EXISTS(\r\n        SELECT 1 FROM meal_items mi\r\n        WHERE mi.nutrition_log_id = dnl.id\r\n        AND mi.from_ai_plan = TRUE\r\n      )\r\n    )\r\n  )\r\n  INTO v_logged_meals\r\n  FROM daily_nutrition_logs dnl\r\n  WHERE user_id = p_user_id\r\n    AND log_date = p_date;\r\n\r\n  v_logged_meals := COALESCE(v_logged_meals, '[]'::jsonb);\r\n  v_meals_total := jsonb_array_length(v_planned_meals);\r\n\r\n  -- Count how many planned meals were followed\r\n  -- (Simplified logic - would need more complex matching in production)\r\n\r\n  -- Insert or update adherence record\r\n  INSERT INTO meal_plan_adherence (\r\n    user_id,\r\n    meal_plan_id,\r\n    tracking_date,\r\n    planned_meals,\r\n    logged_meals,\r\n    meals_followed,\r\n    meals_total\r\n  )\r\n  VALUES (\r\n    p_user_id,\r\n    p_meal_plan_id,\r\n    p_date,\r\n    v_planned_meals,\r\n    v_logged_meals,\r\n    v_meals_followed,\r\n    v_meals_total\r\n  )\r\n  ON CONFLICT (user_id, meal_plan_id, tracking_date)\r\n  DO UPDATE SET\r\n    logged_meals = v_logged_meals,\r\n    meals_followed = v_meals_followed,\r\n    updated_at = NOW();\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "calculate_nutrition_trends",
    "arguments": "p_user_id uuid, p_date date",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION public.calculate_nutrition_trends(p_user_id uuid, p_date date)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_avg_calories_7d INTEGER;\r\n  v_avg_calories_30d INTEGER;\r\n  v_avg_protein_7d FLOAT;\r\n  v_avg_protein_30d FLOAT;\r\n  v_avg_carbs_7d FLOAT;\r\n  v_avg_carbs_30d FLOAT;\r\n  v_avg_fats_7d FLOAT;\r\n  v_avg_fats_30d FLOAT;\r\n  v_calories_variance_7d FLOAT;\r\n  v_calories_variance_30d FLOAT;\r\n  v_protein_pct FLOAT;\r\n  v_carbs_pct FLOAT;\r\n  v_fats_pct FLOAT;\r\n  v_total_macros FLOAT;\r\nBEGIN\r\n  -- Calculate 7-day averages\r\n  SELECT\r\n    AVG(total_calories),\r\n    AVG(total_protein),\r\n    AVG(total_carbs),\r\n    AVG(total_fats),\r\n    STDDEV(total_calories)\r\n  INTO\r\n    v_avg_calories_7d,\r\n    v_avg_protein_7d,\r\n    v_avg_carbs_7d,\r\n    v_avg_fats_7d,\r\n    v_calories_variance_7d\r\n  FROM daily_nutrition_logs\r\n  WHERE user_id = p_user_id\r\n    AND log_date BETWEEN p_date - INTERVAL '6 days' AND p_date;\r\n\r\n  -- Calculate 30-day averages\r\n  SELECT\r\n    AVG(total_calories),\r\n    AVG(total_protein),\r\n    AVG(total_carbs),\r\n    AVG(total_fats),\r\n    STDDEV(total_calories)\r\n  INTO\r\n    v_avg_calories_30d,\r\n    v_avg_protein_30d,\r\n    v_avg_carbs_30d,\r\n    v_avg_fats_30d,\r\n    v_calories_variance_30d\r\n  FROM daily_nutrition_logs\r\n  WHERE user_id = p_user_id\r\n    AND log_date BETWEEN p_date - INTERVAL '29 days' AND p_date;\r\n\r\n  -- Calculate macro percentages (from 7-day average)\r\n  v_total_macros := (v_avg_protein_7d * 4) + (v_avg_carbs_7d * 4) + (v_avg_fats_7d * 9);\r\n\r\n  IF v_total_macros > 0 THEN\r\n    v_protein_pct := (v_avg_protein_7d * 4 / v_total_macros) * 100;\r\n    v_carbs_pct := (v_avg_carbs_7d * 4 / v_total_macros) * 100;\r\n    v_fats_pct := (v_avg_fats_7d * 9 / v_total_macros) * 100;\r\n  END IF;\r\n\r\n  -- Insert or update trend\r\n  INSERT INTO nutrition_trends (\r\n    user_id,\r\n    trend_date,\r\n    avg_calories_7d,\r\n    avg_calories_30d,\r\n    avg_protein_7d,\r\n    avg_protein_30d,\r\n    avg_carbs_7d,\r\n    avg_carbs_30d,\r\n    avg_fats_7d,\r\n    avg_fats_30d,\r\n    calories_variance_7d,\r\n    calories_variance_30d,\r\n    protein_percentage,\r\n    carbs_percentage,\r\n    fats_percentage\r\n  )\r\n  VALUES (\r\n    p_user_id,\r\n    p_date,\r\n    v_avg_calories_7d,\r\n    v_avg_calories_30d,\r\n    v_avg_protein_7d,\r\n    v_avg_protein_30d,\r\n    v_avg_carbs_7d,\r\n    v_avg_carbs_30d,\r\n    v_avg_fats_7d,\r\n    v_avg_fats_30d,\r\n    v_calories_variance_7d,\r\n    v_calories_variance_30d,\r\n    v_protein_pct,\r\n    v_carbs_pct,\r\n    v_fats_pct\r\n  )\r\n  ON CONFLICT (user_id, trend_date)\r\n  DO UPDATE SET\r\n    avg_calories_7d = v_avg_calories_7d,\r\n    avg_calories_30d = v_avg_calories_30d,\r\n    avg_protein_7d = v_avg_protein_7d,\r\n    avg_protein_30d = v_avg_protein_30d,\r\n    avg_carbs_7d = v_avg_carbs_7d,\r\n    avg_carbs_30d = v_avg_carbs_30d,\r\n    avg_fats_7d = v_avg_fats_7d,\r\n    avg_fats_30d = v_avg_fats_30d,\r\n    calories_variance_7d = v_calories_variance_7d,\r\n    calories_variance_30d = v_calories_variance_30d,\r\n    protein_percentage = v_protein_pct,\r\n    carbs_percentage = v_carbs_pct,\r\n    fats_percentage = v_fats_pct;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "can_regenerate_plan",
    "arguments": "p_user_id uuid, p_plan_type text, p_regeneration_type text DEFAULT 'manual'::text",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.can_regenerate_plan(p_user_id uuid, p_plan_type text, p_regeneration_type text DEFAULT 'manual'::text)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n    v_tier TEXT;\r\n    v_monthly_limit INTEGER;\r\n    v_period_start TIMESTAMPTZ;\r\n    v_current_usage INTEGER;\r\nBEGIN\r\n    -- Get user tier\r\n    SELECT tier INTO v_tier\r\n    FROM subscriptions\r\n    WHERE user_id = p_user_id AND status = 'active';\r\n\r\n    v_tier := COALESCE(v_tier, 'free');\r\n\r\n    -- Tier upgrades are ALWAYS allowed (encourage profile completion)\r\n    IF p_regeneration_type = 'tier_upgrade' THEN\r\n        RETURN TRUE;\r\n    END IF;\r\n\r\n    -- Critical field updates are ALWAYS allowed (safety + UX)\r\n    IF p_regeneration_type = 'critical_field' THEN\r\n        RETURN TRUE;\r\n    END IF;\r\n\r\n    -- For manual regenerations, check limits based on tier\r\n    IF v_tier IN ('pro', 'premium') THEN\r\n        -- Pro/Premium: unlimited manual regenerations\r\n        RETURN TRUE;\r\n    END IF;\r\n\r\n    -- Free tier: 1 manual regeneration per month\r\n    IF v_tier = 'free' THEN\r\n        v_period_start := DATE_TRUNC('month', NOW());\r\n\r\n        -- Get current usage for this month\r\n        SELECT COALESCE(\r\n            CASE\r\n                WHEN p_plan_type = 'meal' THEN meal_plan_regenerations\r\n                WHEN p_plan_type = 'workout' THEN workout_plan_regenerations\r\n                ELSE 0\r\n            END,\r\n            0\r\n        ) INTO v_current_usage\r\n        FROM plan_regeneration_usage\r\n        WHERE user_id = p_user_id\r\n          AND period_start = v_period_start;\r\n\r\n        -- Get monthly limit (1 for free tier)\r\n        SELECT ai_generations_per_month INTO v_monthly_limit\r\n        FROM subscription_tiers\r\n        WHERE tier = v_tier;\r\n\r\n        RETURN COALESCE(v_current_usage, 0) < v_monthly_limit;\r\n    END IF;\r\n\r\n    RETURN FALSE;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "can_use_feature",
    "arguments": "p_user_id uuid, p_feature text",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.can_use_feature(p_user_id uuid, p_feature text)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE\nAS $function$DECLARE\r\n  v_tier TEXT;\r\n  v_limit INTEGER;\r\n  v_bool_limit BOOLEAN;\r\n  v_usage INTEGER;\r\n  v_period_start TIMESTAMPTZ;\r\nBEGIN\r\n  -- Get user tier\r\n  SELECT tier INTO v_tier\r\n  FROM subscriptions\r\n  WHERE user_id = p_user_id;\r\n\r\n  -- If no subscription, assume free\r\n  v_tier := COALESCE(v_tier, 'free');\r\n\r\n  -- Get feature limit for tier\r\n  CASE p_feature\r\n    WHEN 'ai_meal_plan', 'ai_workout_plan' THEN\r\n      SELECT ai_generations_per_month INTO v_limit\r\n      FROM subscription_tiers\r\n      WHERE tier = v_tier;\r\n    WHEN 'barcode_scanner' THEN\r\n      SELECT can_access_barcode_scanner INTO v_bool_limit\r\n      FROM subscription_tiers\r\n      WHERE tier = v_tier;\r\n      RETURN v_bool_limit;\r\n    WHEN 'social_features' THEN\r\n      SELECT can_access_social_features INTO v_bool_limit\r\n      FROM subscription_tiers\r\n      WHERE tier = v_tier;\r\n      RETURN v_bool_limit;\r\n    ELSE\r\n      RETURN TRUE; -- Unknown features are allowed by default\r\n  END CASE;\r\n\r\n  -- Get current usage\r\n  v_period_start := DATE_TRUNC('month', NOW());\r\n\r\n  SELECT COALESCE(usage_count, 0) INTO v_usage\r\n  FROM usage_metrics\r\n  WHERE user_id = p_user_id\r\n    AND feature = p_feature\r\n    AND period_start = v_period_start;\r\n\r\n  RETURN v_usage < v_limit;\r\nEND;$function$\n"
  },
  {
    "function_name": "check_and_update_personal_records",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.check_and_update_personal_records()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_current_pr RECORD;\r\n  v_is_pr_weight BOOLEAN := FALSE;\r\n  v_is_pr_reps BOOLEAN := FALSE;\r\n  v_is_pr_volume BOOLEAN := FALSE;\r\n  v_current_volume FLOAT;\r\nBEGIN\r\n  -- Skip warmup sets and null values\r\n  IF NEW.is_warmup OR NEW.exercise_id IS NULL THEN\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  -- Calculate volume for this set\r\n  v_current_volume := COALESCE(NEW.weight_kg, 0) * COALESCE(NEW.reps, 0);\r\n\r\n  -- Get current PRs\r\n  SELECT * INTO v_current_pr\r\n  FROM exercise_personal_records\r\n  WHERE user_id = NEW.user_id\r\n    AND exercise_id = NEW.exercise_id;\r\n\r\n  -- Check for weight PR\r\n  IF NEW.weight_kg IS NOT NULL AND\r\n     (v_current_pr IS NULL OR NEW.weight_kg > COALESCE(v_current_pr.max_weight_kg, 0))\r\n  THEN\r\n    v_is_pr_weight := TRUE;\r\n  END IF;\r\n\r\n  -- Check for reps PR (at same or higher weight)\r\n  IF NEW.reps IS NOT NULL AND\r\n     (v_current_pr IS NULL OR NEW.reps > COALESCE(v_current_pr.max_reps, 0))\r\n  THEN\r\n    v_is_pr_reps := TRUE;\r\n  END IF;\r\n\r\n  -- Check for volume PR\r\n  IF v_current_volume > 0 AND\r\n     (v_current_pr IS NULL OR v_current_volume > COALESCE(v_current_pr.max_volume_kg, 0))\r\n  THEN\r\n    v_is_pr_volume := TRUE;\r\n  END IF;\r\n\r\n  -- Update PR flags in the set\r\n  NEW.is_pr_weight := v_is_pr_weight;\r\n  NEW.is_pr_reps := v_is_pr_reps;\r\n  NEW.is_pr_volume := v_is_pr_volume;\r\n\r\n  -- Update or insert PR record\r\n  IF v_is_pr_weight OR v_is_pr_reps OR v_is_pr_volume THEN\r\n    INSERT INTO exercise_personal_records (\r\n      user_id,\r\n      exercise_id,\r\n      max_weight_kg,\r\n      max_weight_date,\r\n      max_weight_set_id,\r\n      max_reps,\r\n      max_reps_date,\r\n      max_reps_set_id,\r\n      max_volume_kg,\r\n      max_volume_date,\r\n      max_volume_set_id\r\n    )\r\n    VALUES (\r\n      NEW.user_id,\r\n      NEW.exercise_id,\r\n      CASE WHEN v_is_pr_weight THEN NEW.weight_kg ELSE NULL END,\r\n      CASE WHEN v_is_pr_weight THEN CURRENT_DATE ELSE NULL END,\r\n      CASE WHEN v_is_pr_weight THEN NEW.id ELSE NULL END,\r\n      CASE WHEN v_is_pr_reps THEN NEW.reps ELSE NULL END,\r\n      CASE WHEN v_is_pr_reps THEN CURRENT_DATE ELSE NULL END,\r\n      CASE WHEN v_is_pr_reps THEN NEW.id ELSE NULL END,\r\n      CASE WHEN v_is_pr_volume THEN v_current_volume ELSE NULL END,\r\n      CASE WHEN v_is_pr_volume THEN CURRENT_DATE ELSE NULL END,\r\n      CASE WHEN v_is_pr_volume THEN NEW.id ELSE NULL END\r\n    )\r\n    ON CONFLICT (user_id, exercise_id)\r\n    DO UPDATE SET\r\n      max_weight_kg = CASE WHEN v_is_pr_weight THEN NEW.weight_kg ELSE exercise_personal_records.max_weight_kg END,\r\n      max_weight_date = CASE WHEN v_is_pr_weight THEN CURRENT_DATE ELSE exercise_personal_records.max_weight_date END,\r\n      max_weight_set_id = CASE WHEN v_is_pr_weight THEN NEW.id ELSE exercise_personal_records.max_weight_set_id END,\r\n      max_reps = CASE WHEN v_is_pr_reps THEN NEW.reps ELSE exercise_personal_records.max_reps END,\r\n      max_reps_date = CASE WHEN v_is_pr_reps THEN CURRENT_DATE ELSE exercise_personal_records.max_reps_date END,\r\n      max_reps_set_id = CASE WHEN v_is_pr_reps THEN NEW.id ELSE exercise_personal_records.max_reps_set_id END,\r\n      max_volume_kg = CASE WHEN v_is_pr_volume THEN v_current_volume ELSE exercise_personal_records.max_volume_kg END,\r\n      max_volume_date = CASE WHEN v_is_pr_volume THEN CURRENT_DATE ELSE exercise_personal_records.max_volume_date END,\r\n      max_volume_set_id = CASE WHEN v_is_pr_volume THEN NEW.id ELSE exercise_personal_records.max_volume_set_id END,\r\n      updated_at = NOW();\r\n\r\n    -- Send notification for PR\r\n    IF v_is_pr_weight OR v_is_pr_reps OR v_is_pr_volume THEN\r\n      INSERT INTO notifications (user_id, type, title, message, icon)\r\n      VALUES (\r\n        NEW.user_id,\r\n        'achievement',\r\n        'New Personal Record! üéâ',\r\n        format('Congrats! You set a new PR on %s: %s',\r\n          NEW.exercise_name,\r\n          CASE\r\n            WHEN v_is_pr_weight THEN format('%s kg', NEW.weight_kg)\r\n            WHEN v_is_pr_reps THEN format('%s reps', NEW.reps)\r\n            WHEN v_is_pr_volume THEN format('%s kg total volume', v_current_volume)\r\n          END\r\n        ),\r\n        'üèÜ'\r\n      );\r\n    END IF;\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "check_export_expiration",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.check_export_expiration()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF NEW.expires_at < NOW() AND NEW.status = 'completed' THEN\r\n    NEW.status := 'expired';\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "create_coupon_from_reward",
    "arguments": "p_user_id uuid, p_reward_id uuid, p_reward_name text, p_discount_type text, p_discount_value text, p_expires_days integer DEFAULT 30",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION public.create_coupon_from_reward(p_user_id uuid, p_reward_id uuid, p_reward_name text, p_discount_type text, p_discount_value text, p_expires_days integer DEFAULT 30)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_code TEXT;\r\n  v_expires_at TIMESTAMPTZ;\r\nBEGIN\r\n  -- Generate unique code\r\n  v_code := generate_coupon_code();\r\n\r\n  -- Calculate expiration\r\n  v_expires_at := NOW() + (p_expires_days || ' days')::INTERVAL;\r\n\r\n  -- Insert coupon\r\n  INSERT INTO coupon_codes (\r\n    user_id,\r\n    code,\r\n    discount_type,\r\n    discount_value,\r\n    reward_id,\r\n    reward_name,\r\n    expires_at\r\n  ) VALUES (\r\n    p_user_id,\r\n    v_code,\r\n    p_discount_type,\r\n    p_discount_value,\r\n    p_reward_id,\r\n    p_reward_name,\r\n    v_expires_at\r\n  );\r\n\r\n  RETURN v_code;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "create_milestone_timeline_event",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.create_milestone_timeline_event()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF NEW.status = 'achieved' AND (OLD.status IS NULL OR OLD.status != 'achieved') THEN\r\n    INSERT INTO user_journey_timeline (\r\n      user_id,\r\n      event_type,\r\n      title,\r\n      description,\r\n      related_entity_type,\r\n      related_entity_id,\r\n      event_data,\r\n      is_highlighted\r\n    )\r\n    VALUES (\r\n      NEW.user_id,\r\n      'milestone_achieved',\r\n      format('Milestone Achieved: %s', NEW.milestone_name),\r\n      NEW.description,\r\n      'milestone',\r\n      NEW.id,\r\n      jsonb_build_object(\r\n        'milestone_type', NEW.milestone_type,\r\n        'achieved_value', NEW.achieved_value,\r\n        'unit', NEW.unit,\r\n        'points_awarded', NEW.points_awarded\r\n      ),\r\n      TRUE -- Highlight milestone achievements\r\n    );\r\n\r\n    -- Award points\r\n    IF NEW.points_awarded > 0 THEN\r\n      PERFORM award_points(NEW.user_id, NEW.points_awarded, NEW.milestone_name);\r\n    END IF;\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "create_weight_log_timeline_event",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.create_weight_log_timeline_event()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Only create timeline event every 7 days or for significant changes (>2kg)\r\n  IF NOT EXISTS (\r\n    SELECT 1 FROM user_journey_timeline\r\n    WHERE user_id = NEW.user_id\r\n      AND event_type = 'weight_logged'\r\n      AND event_date > NOW() - INTERVAL '7 days'\r\n  ) OR ABS(NEW.weight_kg - (\r\n    SELECT weight FROM profiles WHERE id = NEW.user_id\r\n  )) > 2 THEN\r\n    INSERT INTO user_journey_timeline (\r\n      user_id,\r\n      event_type,\r\n      title,\r\n      description,\r\n      event_data\r\n    )\r\n    VALUES (\r\n      NEW.user_id,\r\n      'weight_logged',\r\n      format('Weight Update: %.1f kg', NEW.weight_kg),\r\n      NEW.notes,\r\n      jsonb_build_object(\r\n        'weight_kg', NEW.weight_kg,\r\n        'measurement_date', NEW.measurement_date\r\n      )\r\n    );\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "deactivate_old_meal_plans",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.deactivate_old_meal_plans()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF NEW.is_active = TRUE THEN\r\n    UPDATE ai_meal_plans\r\n    SET is_active = FALSE\r\n    WHERE user_id = NEW.user_id\r\n      AND id != NEW.id\r\n      AND is_active = TRUE;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "deactivate_old_workout_plans",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.deactivate_old_workout_plans()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF NEW.is_active = TRUE THEN\r\n    UPDATE ai_workout_plans\r\n    SET is_active = FALSE\r\n    WHERE user_id = NEW.user_id\r\n      AND id != NEW.id\r\n      AND is_active = TRUE;\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "determine_tier",
    "arguments": "p_completeness double precision",
    "return_type": "character varying",
    "definition": "CREATE OR REPLACE FUNCTION public.determine_tier(p_completeness double precision)\n RETURNS character varying\n LANGUAGE plpgsql\nAS $function$BEGIN\r\n    IF p_completeness < 30 THEN\r\n        RETURN 'BASIC';\r\n    ELSE\r\n        RETURN 'PREMIUM';\r\n    END IF;\r\nEND;$function$\n"
  },
  {
    "function_name": "generate_ai_insight",
    "arguments": "p_user_id uuid, p_insight_type text, p_category text, p_title text, p_message text, p_priority text DEFAULT 'normal'::text, p_recommendations jsonb DEFAULT '[]'::jsonb",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION public.generate_ai_insight(p_user_id uuid, p_insight_type text, p_category text, p_title text, p_message text, p_priority text DEFAULT 'normal'::text, p_recommendations jsonb DEFAULT '[]'::jsonb)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_insight_id UUID;\r\nBEGIN\r\n  INSERT INTO ai_insights (\r\n    user_id,\r\n    insight_type,\r\n    category,\r\n    title,\r\n    message,\r\n    priority,\r\n    recommendations,\r\n    importance_score,\r\n    expires_at\r\n  )\r\n  VALUES (\r\n    p_user_id,\r\n    p_insight_type,\r\n    p_category,\r\n    p_title,\r\n    p_message,\r\n    p_priority,\r\n    p_recommendations,\r\n    CASE p_priority\r\n      WHEN 'urgent' THEN 90\r\n      WHEN 'high' THEN 70\r\n      WHEN 'normal' THEN 50\r\n      ELSE 30\r\n    END,\r\n    CASE p_priority\r\n      WHEN 'urgent' THEN NOW() + INTERVAL '3 days'\r\n      WHEN 'high' THEN NOW() + INTERVAL '7 days'\r\n      ELSE NOW() + INTERVAL '14 days'\r\n    END\r\n  )\r\n  RETURNING id INTO v_insight_id;\r\n\r\n  -- Create notification\r\n  INSERT INTO notifications (user_id, type, title, message, action_url)\r\n  VALUES (\r\n    p_user_id,\r\n    'info',\r\n    'New Insight Available',\r\n    p_title,\r\n    '/dashboard?tab=insights'\r\n  );\r\n\r\n  RETURN v_insight_id;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "generate_coupon_code",
    "arguments": "",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION public.generate_coupon_code()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_code TEXT;\r\n  v_exists BOOLEAN;\r\nBEGIN\r\n  LOOP\r\n    -- Generate random 10-character code (uppercase letters and numbers)\r\n    v_code := 'GL-' || upper(substr(md5(random()::text || clock_timestamp()::text), 1, 8));\r\n\r\n    -- Check if code already exists\r\n    SELECT EXISTS(SELECT 1 FROM coupon_codes WHERE code = v_code) INTO v_exists;\r\n\r\n    EXIT WHEN NOT v_exists;\r\n  END LOOP;\r\n\r\n  RETURN v_code;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_current_nutrition_goals",
    "arguments": "p_user_id uuid",
    "return_type": "TABLE(daily_calories integer, daily_protein_g double precision, daily_carbs_g double precision, daily_fats_g double precision, daily_fiber_g double precision, daily_water_ml integer)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_current_nutrition_goals(p_user_id uuid)\n RETURNS TABLE(daily_calories integer, daily_protein_g double precision, daily_carbs_g double precision, daily_fats_g double precision, daily_fiber_g double precision, daily_water_ml integer)\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT\r\n    ngh.daily_calories,\r\n    ngh.daily_protein_g,\r\n    ngh.daily_carbs_g,\r\n    ngh.daily_fats_g,\r\n    ngh.daily_fiber_g,\r\n    ngh.daily_water_ml\r\n  FROM nutrition_goals_history ngh\r\n  WHERE ngh.user_id = p_user_id\r\n    AND ngh.effective_date <= CURRENT_DATE\r\n    AND (ngh.end_date IS NULL OR ngh.end_date >= CURRENT_DATE)\r\n  ORDER BY ngh.effective_date DESC\r\n  LIMIT 1;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_current_week_adherence",
    "arguments": "p_user_id uuid, p_plan_id uuid",
    "return_type": "TABLE(planned_workouts integer, completed_workouts integer, adherence_percentage double precision)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_current_week_adherence(p_user_id uuid, p_plan_id uuid)\n RETURNS TABLE(planned_workouts integer, completed_workouts integer, adherence_percentage double precision)\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nDECLARE\r\n  v_week_start DATE := DATE_TRUNC('week', CURRENT_DATE)::DATE;\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT\r\n    wpa.planned_workouts,\r\n    wpa.completed_workouts,\r\n    wpa.adherence_percentage\r\n  FROM workout_plan_adherence wpa\r\n  WHERE wpa.user_id = p_user_id\r\n    AND wpa.workout_plan_id = p_plan_id\r\n    AND wpa.tracking_week_start = v_week_start;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_progress_summary",
    "arguments": "p_user_id uuid, p_start_date date, p_end_date date",
    "return_type": "TABLE(weight_change_kg double precision, total_workouts integer, total_meals_logged integer, prs_achieved integer)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_progress_summary(p_user_id uuid, p_start_date date, p_end_date date)\n RETURNS TABLE(weight_change_kg double precision, total_workouts integer, total_meals_logged integer, prs_achieved integer)\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\nBEGIN\r\n  RETURN QUERY\r\n  SELECT\r\n    (SELECT ending_weight_kg - starting_weight_kg\r\n     FROM (\r\n       SELECT\r\n         (SELECT weight_kg FROM body_measurements WHERE user_id = p_user_id AND measurement_date >= p_start_date ORDER BY measurement_date ASC LIMIT 1) AS starting_weight_kg,\r\n         (SELECT weight_kg FROM body_measurements WHERE user_id = p_user_id AND measurement_date <= p_end_date ORDER BY measurement_date DESC LIMIT 1) AS ending_weight_kg\r\n     ) AS weights\r\n    ),\r\n    (SELECT COUNT(*)::INTEGER FROM workout_sessions WHERE user_id = p_user_id AND session_date BETWEEN p_start_date AND p_end_date AND status = 'completed'),\r\n    (SELECT COUNT(DISTINCT log_date)::INTEGER FROM daily_nutrition_logs WHERE user_id = p_user_id AND log_date BETWEEN p_start_date AND p_end_date),\r\n    (SELECT COUNT(*)::INTEGER FROM exercise_sets WHERE user_id = p_user_id AND created_at::DATE BETWEEN p_start_date AND p_end_date AND (is_pr_weight OR is_pr_reps OR is_pr_volume));\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "handle_new_user",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  INSERT INTO public.profiles (\r\n    id,\r\n    email,\r\n    full_name,\r\n    username,\r\n    onboarding_completed,\r\n    onboarding_step,\r\n    created_at,\r\n    updated_at\r\n  )\r\n  VALUES (\r\n    NEW.id,\r\n    NEW.email,\r\n    COALESCE(NEW.raw_user_meta_data->>'full_name', 'User'),\r\n    COALESCE(NEW.raw_user_meta_data->>'username', LOWER(SPLIT_PART(NEW.email, '@', 1))),\r\n    FALSE,\r\n    0,\r\n    NOW(),\r\n    NOW()\r\n  );\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "handle_new_user_subscription",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_new_user_subscription()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\n\r\nBEGIN\r\n\r\n  -- Create free tier subscription\r\n\r\n  INSERT INTO public.subscriptions (\r\n\r\n    user_id,\r\n\r\n    tier,\r\n\r\n    status,\r\n\r\n    created_at,\r\n\r\n    updated_at\r\n\r\n  )\r\n\r\n  VALUES (\r\n\r\n    NEW.id,\r\n\r\n    'free',\r\n\r\n    'active',\r\n\r\n    NOW(),\r\n\r\n    NOW()\r\n\r\n  );\r\n\r\n \r\n\r\n  RETURN NEW;\r\n\r\nEND;\r\n\r\n$function$\n"
  },
  {
    "function_name": "notify_badge_earned",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.notify_badge_earned()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_badge_name TEXT;\r\nBEGIN\r\n  -- Get badge name\r\n  SELECT name INTO v_badge_name\r\n  FROM badges\r\n  WHERE id = NEW.badge_id;\r\n\r\n  -- Create notification using user_id (not recipient_id)\r\n  INSERT INTO notifications (\r\n    user_id,\r\n    type,\r\n    title,\r\n    message,\r\n    icon,\r\n    metadata\r\n  ) VALUES (\r\n    NEW.user_id,\r\n    'achievement',\r\n    'Badge Earned!',\r\n    'You earned the \"' || v_badge_name || '\" badge!',\r\n    'üèÜ',\r\n    jsonb_build_object('badge_id', NEW.badge_id, 'badge_name', v_badge_name)\r\n  );\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "notify_challenge_completed",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.notify_challenge_completed()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_challenge_title TEXT;\r\n  v_challenge_points INTEGER;\r\nBEGIN\r\n  -- Only notify when challenge is marked complete\r\n  IF NEW.completed = TRUE AND (OLD.completed = FALSE OR OLD.completed IS NULL) THEN\r\n    -- Get challenge details\r\n    SELECT title, points INTO v_challenge_title, v_challenge_points\r\n    FROM challenges\r\n    WHERE id = NEW.challenge_id;\r\n\r\n    -- Create notification\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      icon,\r\n      action_url,\r\n      metadata\r\n    ) VALUES (\r\n      NEW.user_id,\r\n      'achievement',\r\n      'Challenge Complete!',\r\n      'You completed \"' || v_challenge_title || '\"! +' || v_challenge_points || ' points!',\r\n      'üéâ',\r\n      '/challenges',\r\n      jsonb_build_object('challenge_id', NEW.challenge_id, 'points', v_challenge_points)\r\n    );\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "notify_friend_challenge_join",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.notify_friend_challenge_join()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_challenge_title TEXT;\r\n  v_user_name TEXT;\r\nBEGIN\r\n  -- Get challenge title\r\n  SELECT title INTO v_challenge_title\r\n  FROM challenges\r\n  WHERE id = NEW.challenge_id;\r\n\r\n  -- Get user's name\r\n  SELECT full_name INTO v_user_name\r\n  FROM profiles\r\n  WHERE id = NEW.user_id;\r\n\r\n  -- Notify other participants of this challenge\r\n  INSERT INTO notifications (user_id, type, title, message, icon, action_url, metadata)\r\n  SELECT\r\n    cp.user_id,\r\n    'social',\r\n    'Friend Joined Challenge',\r\n    v_user_name || ' joined \"' || v_challenge_title || '\"!',\r\n    'üëã',\r\n    '/challenges',\r\n    jsonb_build_object('challenge_id', NEW.challenge_id, 'friend_id', NEW.user_id)\r\n  FROM challenge_participants cp\r\n  WHERE cp.challenge_id = NEW.challenge_id\r\n    AND cp.user_id != NEW.user_id;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "notify_streak_milestone",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.notify_streak_milestone()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  -- Notify on specific milestones (7, 14, 30, 50, 100 days)\r\n  IF NEW.current_streak IN (7, 14, 30, 50, 100) AND\r\n     (OLD.current_streak IS NULL OR OLD.current_streak < NEW.current_streak) THEN\r\n\r\n    INSERT INTO notifications (\r\n      user_id,\r\n      type,\r\n      title,\r\n      message,\r\n      icon,\r\n      metadata\r\n    ) VALUES (\r\n      NEW.user_id,\r\n      'achievement',\r\n      'Streak Milestone!',\r\n      NEW.current_streak || ' day ' || REPLACE(NEW.streak_type, '_', ' ') || ' streak! Keep it up!',\r\n      'üî•',\r\n      jsonb_build_object('streak_type', NEW.streak_type, 'streak_count', NEW.current_streak)\r\n    );\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "notify_weight_milestone",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.notify_weight_milestone()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$DECLARE\r\n  v_target_weight FLOAT;\r\n  v_starting_weight FLOAT;\r\n  v_progress FLOAT;\r\nBEGIN\r\n  -- Get target weight\r\n  SELECT target_weight INTO v_target_weight\r\n  FROM profiles\r\n  WHERE id = NEW.user_id;\r\n\r\n  -- Get starting weight (first entry)\r\n  SELECT weight INTO v_starting_weight\r\n  FROM weight_history\r\n  WHERE user_id = NEW.user_id\r\n  ORDER BY log_date ASC\r\n  LIMIT 1;\r\n\r\n  IF v_target_weight IS NOT NULL AND v_starting_weight IS NOT NULL THEN\r\n    -- Calculate progress\r\n    v_progress := ((v_starting_weight - NEW.weight) / (v_starting_weight - v_target_weight)) * 100;\r\n\r\n    -- Notify on milestones (25%, 50%, 75%, 100%)\r\n    IF v_progress >= 25 AND v_progress < 26 THEN\r\n      INSERT INTO notifications (user_id, type, title, message, icon, metadata)\r\n      VALUES (NEW.user_id, 'achievement', 'Weight Goal Progress', '25% to your goal! Amazing progress!', 'üéØ', jsonb_build_object('progress_pct', 25));\r\n    ELSIF v_progress >= 50 AND v_progress < 51 THEN\r\n      INSERT INTO notifications (user_id, type, title, message, icon, metadata)\r\n      VALUES (NEW.user_id, 'achievement', 'Weight Goal Progress', 'Halfway to your goal! Keep crushing it!', 'üéØ', jsonb_build_object('progress_pct', 50));\r\n    ELSIF v_progress >= 75 AND v_progress < 76 THEN\r\n      INSERT INTO notifications (user_id, type, title, message, icon, metadata)\r\n      VALUES (NEW.user_id, 'achievement', 'Weight Goal Progress', '75% there! You are almost at your goal!', 'üéØ', jsonb_build_object('progress_pct', 75));\r\n    ELSIF v_progress >= 100 THEN\r\n      INSERT INTO notifications (user_id, type, title, message, icon, metadata)\r\n      VALUES (NEW.user_id, 'achievement', 'Goal Reached!', 'GOAL REACHED! You did it! Congratulations!', 'üéâ', jsonb_build_object('progress_pct', 100));\r\n    END IF;\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;$function$\n"
  },
  {
    "function_name": "track_regeneration",
    "arguments": "p_user_id uuid, p_plan_type text, p_regeneration_type text DEFAULT 'manual'::text",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION public.track_regeneration(p_user_id uuid, p_plan_type text, p_regeneration_type text DEFAULT 'manual'::text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_period_start TIMESTAMPTZ;\r\n    v_period_end TIMESTAMPTZ;\r\nBEGIN\r\n    -- Only track manual regenerations (tier_upgrade and critical_field don't count against limits)\r\n    IF p_regeneration_type != 'manual' THEN\r\n        RETURN;\r\n    END IF;\r\n\r\n    -- Get current monthly period\r\n    v_period_start := DATE_TRUNC('month', NOW());\r\n    v_period_end := v_period_start + INTERVAL '1 month';\r\n\r\n    -- Insert or update usage\r\n    IF p_plan_type = 'meal' THEN\r\n        INSERT INTO plan_regeneration_usage (user_id, period_start, period_end, meal_plan_regenerations)\r\n        VALUES (p_user_id, v_period_start, v_period_end, 1)\r\n        ON CONFLICT (user_id, period_start)\r\n        DO UPDATE SET\r\n            meal_plan_regenerations = plan_regeneration_usage.meal_plan_regenerations + 1,\r\n            updated_at = NOW();\r\n    ELSIF p_plan_type = 'workout' THEN\r\n        INSERT INTO plan_regeneration_usage (user_id, period_start, period_end, workout_plan_regenerations)\r\n        VALUES (p_user_id, v_period_start, v_period_end, 1)\r\n        ON CONFLICT (user_id, period_start)\r\n        DO UPDATE SET\r\n            workout_plan_regenerations = plan_regeneration_usage.workout_plan_regenerations + 1,\r\n            updated_at = NOW();\r\n    END IF;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "track_usage",
    "arguments": "p_user_id uuid, p_feature text, p_increment integer DEFAULT 1",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION public.track_usage(p_user_id uuid, p_feature text, p_increment integer DEFAULT 1)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_period_start TIMESTAMPTZ;\r\n  v_period_end TIMESTAMPTZ;\r\nBEGIN\r\n  -- Get current monthly period\r\n  v_period_start := DATE_TRUNC('month', NOW());\r\n  v_period_end := v_period_start + INTERVAL '1 month';\r\n\r\n  -- Insert or update usage\r\n  INSERT INTO usage_metrics (user_id, feature, period_start, period_end, usage_count)\r\n  VALUES (p_user_id, p_feature, v_period_start, v_period_end, p_increment)\r\n  ON CONFLICT (user_id, feature, period_start)\r\n  DO UPDATE SET\r\n    usage_count = usage_metrics.usage_count + p_increment,\r\n    updated_at = NOW();\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "trigger_update_nutrition_streak",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.trigger_update_nutrition_streak()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  PERFORM update_user_streak(NEW.user_id, 'nutrition_logging', NEW.log_date);\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "trigger_update_weight_streak",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.trigger_update_weight_streak()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  PERFORM update_user_streak(NEW.user_id, 'daily_weigh_in', NEW.log_date);\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "trigger_update_workout_streak",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.trigger_update_workout_streak()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF NEW.completed = TRUE THEN\r\n    PERFORM update_user_streak(NEW.user_id, 'workout_logging', NEW.workout_date);\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "update_bmi",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.update_bmi()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  user_height_cm FLOAT;\r\nBEGIN\r\n  SELECT height INTO user_height_cm FROM profiles WHERE id = NEW.user_id;\r\n\r\n  IF user_height_cm > 0 THEN\r\n    NEW.bmi := NEW.weight_kg / POWER(user_height_cm / 100.0, 2);\r\n  ELSE\r\n    NEW.bmi := NULL;\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "update_daily_water_total",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.update_daily_water_total()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Upsert daily total\r\n  INSERT INTO daily_water_intake (user_id, log_date, total_ml, glasses)\r\n  VALUES (\r\n    COALESCE(NEW.user_id, OLD.user_id),\r\n    COALESCE(NEW.log_date, OLD.log_date),\r\n    (\r\n      SELECT COALESCE(SUM(amount_ml), 0)\r\n      FROM water_intake_logs\r\n      WHERE user_id = COALESCE(NEW.user_id, OLD.user_id)\r\n        AND log_date = COALESCE(NEW.log_date, OLD.log_date)\r\n    ),\r\n    (\r\n      SELECT COUNT(*)\r\n      FROM water_intake_logs\r\n      WHERE user_id = COALESCE(NEW.user_id, OLD.user_id)\r\n        AND log_date = COALESCE(NEW.log_date, OLD.log_date)\r\n    )\r\n  )\r\n  ON CONFLICT (user_id, log_date)\r\n  DO UPDATE SET\r\n    total_ml = EXCLUDED.total_ml,\r\n    glasses = EXCLUDED.glasses,\r\n    updated_at = NOW();\r\n\r\n  RETURN COALESCE(NEW, OLD);\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "update_nutrition_log_totals",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.update_nutrition_log_totals()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_nutrition_log_id UUID;\r\n  v_total_calories FLOAT;\r\n  v_total_protein FLOAT;\r\n  v_total_carbs FLOAT;\r\n  v_total_fats FLOAT;\r\nBEGIN\r\n  -- Get nutrition_log_id from NEW or OLD record\r\n  v_nutrition_log_id := COALESCE(NEW.nutrition_log_id, OLD.nutrition_log_id);\r\n\r\n  IF v_nutrition_log_id IS NULL THEN\r\n    RETURN COALESCE(NEW, OLD);\r\n  END IF;\r\n\r\n  -- Calculate new totals\r\n  SELECT\r\n    COALESCE(SUM(calories), 0),\r\n    COALESCE(SUM(protein), 0),\r\n    COALESCE(SUM(carbs), 0),\r\n    COALESCE(SUM(fats), 0)\r\n  INTO\r\n    v_total_calories,\r\n    v_total_protein,\r\n    v_total_carbs,\r\n    v_total_fats\r\n  FROM meal_items\r\n  WHERE nutrition_log_id = v_nutrition_log_id;\r\n\r\n  -- Update parent daily_nutrition_logs record\r\n  UPDATE daily_nutrition_logs\r\n  SET\r\n    total_calories = v_total_calories,\r\n    total_protein = v_total_protein,\r\n    total_carbs = v_total_carbs,\r\n    total_fats = v_total_fats\r\n  WHERE id = v_nutrition_log_id;\r\n\r\n  RETURN COALESCE(NEW, OLD);\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "update_profile_completeness",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.update_profile_completeness()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    v_completeness FLOAT;\r\n    v_tier VARCHAR(20);\r\nBEGIN\r\n    v_completeness := calculate_profile_completeness(NEW.user_id);\r\n    v_tier := determine_tier(v_completeness);\r\n\r\n    NEW.completeness_percentage := v_completeness;\r\n    NEW.current_tier := v_tier;\r\n    NEW.updated_at := NOW();\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "update_timestamp",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.update_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.updated_at = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "update_user_streak",
    "arguments": "p_user_id uuid, p_streak_type text, p_log_date date DEFAULT CURRENT_DATE",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION public.update_user_streak(p_user_id uuid, p_streak_type text, p_log_date date DEFAULT CURRENT_DATE)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_last_logged_date DATE;\r\n  v_current_streak INTEGER;\r\n  v_longest_streak INTEGER;\r\n  v_total_days INTEGER;\r\nBEGIN\r\n  -- Get current streak data\r\n  SELECT last_logged_date, current_streak, longest_streak, total_days_logged\r\n  INTO v_last_logged_date, v_current_streak, v_longest_streak, v_total_days\r\n  FROM user_streaks\r\n  WHERE user_id = p_user_id AND streak_type = p_streak_type;\r\n\r\n  -- If no record exists, create one\r\n  IF NOT FOUND THEN\r\n    INSERT INTO user_streaks (user_id, streak_type, current_streak, longest_streak, last_logged_date, streak_start_date, total_days_logged)\r\n    VALUES (p_user_id, p_streak_type, 1, 1, p_log_date, p_log_date, 1);\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- If logging for the same day, don't update\r\n  IF v_last_logged_date = p_log_date THEN\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- If logging for consecutive day\r\n  IF v_last_logged_date = p_log_date - INTERVAL '1 day' THEN\r\n    v_current_streak := v_current_streak + 1;\r\n  -- If streak is broken\r\n  ELSIF v_last_logged_date < p_log_date - INTERVAL '1 day' THEN\r\n    v_current_streak := 1;\r\n  END IF;\r\n\r\n  -- Update longest streak if needed\r\n  IF v_current_streak > v_longest_streak THEN\r\n    v_longest_streak := v_current_streak;\r\n  END IF;\r\n\r\n  -- Update streak record\r\n  UPDATE user_streaks\r\n  SET current_streak = v_current_streak,\r\n      longest_streak = v_longest_streak,\r\n      last_logged_date = p_log_date,\r\n      total_days_logged = v_total_days + 1,\r\n      updated_at = NOW()\r\n  WHERE user_id = p_user_id AND streak_type = p_streak_type;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "update_workout_session_totals",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.update_workout_session_totals()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_session_id UUID;\r\n  v_total_exercises INTEGER;\r\n  v_total_sets INTEGER;\r\n  v_total_reps INTEGER;\r\n  v_total_volume FLOAT;\r\nBEGIN\r\n  v_session_id := COALESCE(NEW.workout_session_id, OLD.workout_session_id);\r\n\r\n  IF v_session_id IS NULL THEN\r\n    RETURN COALESCE(NEW, OLD);\r\n  END IF;\r\n\r\n  -- Calculate totals\r\n  SELECT\r\n    COUNT(DISTINCT exercise_id),\r\n    COUNT(*),\r\n    COALESCE(SUM(reps), 0),\r\n    COALESCE(SUM(weight_kg * reps), 0)\r\n  INTO\r\n    v_total_exercises,\r\n    v_total_sets,\r\n    v_total_reps,\r\n    v_total_volume\r\n  FROM exercise_sets\r\n  WHERE workout_session_id = v_session_id\r\n    AND is_warmup = FALSE; -- Don't count warmup sets\r\n\r\n  -- Update session\r\n  UPDATE workout_sessions\r\n  SET\r\n    total_exercises = v_total_exercises,\r\n    total_sets = v_total_sets,\r\n    total_reps = v_total_reps,\r\n    total_volume_kg = v_total_volume,\r\n    updated_at = NOW()\r\n  WHERE id = v_session_id;\r\n\r\n  RETURN COALESCE(NEW, OLD);\r\nEND;\r\n$function$\n"
  }
]
